<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Bouncing Square with Wall Jump & Touch</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #333;
        display: flex;
        flex-direction: column; /* Allow controls text above canvas */
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: sans-serif;
        color: white;
        -webkit-user-select: none; /* Disable text selection */
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
      }
      canvas {
        border: 1px solid #555;
        background-color: #282c34;
        touch-action: none; /* Crucial for preventing default touch actions like pan/zoom on the canvas */
      }
      #controls-info {
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 10px; /* Space between info and canvas */
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="controls-info">
      <p>Controls:</p>
      <ul>
        <li>
          Keyboard: Left/Right Arrows or A/D (Move), Up Arrow or W or Space
          (Jump)
        </li>
        <li>Touch: Hold Left/Right half (Move), Quick Tap (Jump)</li>
      </ul>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Canvas setup
      canvas.width = Math.min(window.innerWidth * 0.9, 800); // Responsive width
      canvas.height = Math.min(window.innerHeight * 0.7, 600); // Responsive height

      let canvasRect = canvas.getBoundingClientRect(); // Get initial dimensions

      window.addEventListener("resize", () => {
        canvas.width = Math.min(window.innerWidth * 0.9, 800);
        canvas.height = Math.min(window.innerHeight * 0.7, 600);
        canvasRect = canvas.getBoundingClientRect(); // Update on resize
        // Re-center player if needed, or ensure it's within new bounds
        if (player.x > canvas.width - player.size / 2)
          player.x = canvas.width - player.size / 2;
        if (player.y > canvas.height - player.size / 2)
          player.y = canvas.height - player.size / 2;
        // Optional: check left/top as well if desired
        if (player.x < player.size / 2) player.x = player.size / 2;
        if (player.y < player.size / 2) player.y = player.size / 2;
      });

      // Player properties
      const player = {
        x: canvas.width / 2,
        y: canvas.height - 100, // y is the center of the square
        size: 40, // Side length of the square
        color: "#FF0000", 
        eyeColor: "white",
        pupilColor: "black",
        vx: 0,
        vy: 0,
        mass: 1,
        jumpForce: 13,
        moveSpeed: 0.8,
        maxSpeedX: 7,
        onGround: false,
        isTouchingWall: false,
        wallDirection: 0,
        wallSlideSpeed: 1.5,
        wallJumpForceX: 8,
        wallJumpForceY: 12,
      };

      // Environment
      const gravity = 0.6;
      const friction = 0.9;
      const groundFriction = 0.85;

      // Tail particles
      let tailParticles = [];
      const MAX_TAIL_PARTICLES = 60;
      const TAIL_LIFETIME = 30;
      const TAIL_SPAWN_INTERVAL = 1;
      let tailSpawnCounter = 0;

      // Input handling
      const keys = { left: false, right: false, up: false };
      let keyUpJustPressed = false;

      // Touch handling variables
      let activeTouchId = null;
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      const TAP_DURATION_THRESHOLD = 250; // ms
      const TAP_MOVEMENT_THRESHOLD = 25; // pixels

      // Keyboard listeners
      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a")
          keys.left = true;
        if (e.key === "ArrowRight" || e.key.toLowerCase() === "d")
          keys.right = true;
        if (
          e.key === "ArrowUp" ||
          e.key.toLowerCase() === "w" ||
          e.key === " "
        ) {
          if (!keys.up) keyUpJustPressed = true;
          keys.up = true;
        }
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a")
          keys.left = false;
        if (e.key === "ArrowRight" || e.key.toLowerCase() === "d")
          keys.right = false;
        if (e.key === "ArrowUp" || e.key.toLowerCase() === "w" || e.key === " ")
          keys.up = false;
      });

      // Touch listeners
      canvas.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          if (activeTouchId === null) {
            const touch = e.changedTouches[0];
            activeTouchId = touch.identifier;
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
            if (touch.clientX < canvasRect.left + canvas.width / 2) {
              keys.left = true;
              keys.right = false;
            } else {
              keys.right = true;
              keys.left = false;
            }
          }
        },
        { passive: false }
      );

      canvas.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          if (activeTouchId !== null) {
            for (let i = 0; i < e.changedTouches.length; i++) {
              const touch = e.changedTouches[i];
              if (touch.identifier === activeTouchId) {
                if (touch.clientX < canvasRect.left + canvas.width / 2) {
                  keys.left = true;
                  keys.right = false;
                } else {
                  keys.right = true;
                  keys.left = false;
                }
                break;
              }
            }
          }
        },
        { passive: false }
      );

      const handleTouchEnd = (e) => {
        e.preventDefault();
        if (activeTouchId !== null) {
          for (let i = 0; i < e.changedTouches.length; i++) {
            const touch = e.changedTouches[i];
            if (touch.identifier === activeTouchId) {
              const touchEndX = touch.clientX;
              const touchEndY = touch.clientY;
              const touchDuration = Date.now() - touchStartTime;
              const deltaX = touchEndX - touchStartX;
              const deltaY = touchEndY - touchStartY;
              const distanceMoved = Math.sqrt(
                deltaX * deltaX + deltaY * deltaY
              );

              if (
                touchDuration < TAP_DURATION_THRESHOLD &&
                distanceMoved < TAP_MOVEMENT_THRESHOLD
              ) {
                keyUpJustPressed = true;
              }
              keys.left = false;
              keys.right = false;
              activeTouchId = null;
              break;
            }
          }
        }
      };

      canvas.addEventListener("touchend", handleTouchEnd, { passive: false });
      canvas.addEventListener("touchcancel", handleTouchEnd, {
        passive: false,
      });

      function drawPlayer() {
        // Draw square body
        ctx.fillStyle = player.color;
        ctx.fillRect(
          player.x - player.size / 2,
          player.y - player.size / 2,
          player.size,
          player.size
        );

        // Eyes (adjusted for square)
        const eyeRadius = player.size * 0.15; // Proportional to player.size
        const eyeOffsetX = player.size * 0.2; // Proportional to player.size
        const eyeOffsetY = player.size * 0.075; // Positioned slightly up from center

        ctx.fillStyle = player.eyeColor;
        // Left Eye
        ctx.beginPath();
        ctx.arc(
          player.x - eyeOffsetX,
          player.y - eyeOffsetY,
          eyeRadius,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.closePath();
        // Right Eye
        ctx.beginPath();
        ctx.arc(
          player.x + eyeOffsetX,
          player.y - eyeOffsetY,
          eyeRadius,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.closePath();

        const pupilRadius = eyeRadius * 0.5;
        let pupilLookOffset = 0;
        if (player.vx > 0.5) pupilLookOffset = eyeRadius * 0.3;
        else if (player.vx < -0.5) pupilLookOffset = -eyeRadius * 0.3;
        const pupilOffsetY = 0;

        ctx.fillStyle = player.pupilColor;
        // Left Pupil
        ctx.beginPath();
        ctx.arc(
          player.x - eyeOffsetX + pupilLookOffset,
          player.y - eyeOffsetY + pupilOffsetY,
          pupilRadius,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.closePath();
        // Right Pupil
        ctx.beginPath();
        ctx.arc(
          player.x + eyeOffsetX + pupilLookOffset,
          player.y - eyeOffsetY + pupilOffsetY,
          pupilRadius,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.closePath();
      }

      function updatePlayer() {
        if (keys.left) player.vx -= player.moveSpeed;
        if (keys.right) player.vx += player.moveSpeed;

        if (player.onGround) player.vx *= groundFriction;
        else player.vx *= friction;

        player.vx = Math.max(
          -player.maxSpeedX,
          Math.min(player.maxSpeedX, player.vx)
        );
        player.vy += gravity;

        player.isTouchingWall = false;
        player.wallDirection = 0;

        // Wall collisions (using player.size / 2)
        if (player.x - player.size / 2 <= 0) {
          player.x = player.size / 2;
          if (player.vx < 0) player.vx = 0;
          player.isTouchingWall = true;
          player.wallDirection = -1;
        } else if (player.x + player.size / 2 >= canvas.width) {
          player.x = canvas.width - player.size / 2;
          if (player.vx > 0) player.vx = 0;
          player.isTouchingWall = true;
          player.wallDirection = 1;
        }

        if (keyUpJustPressed) {
          if (player.onGround) {
            player.vy = -player.jumpForce;
          } else if (player.isTouchingWall && !player.onGround) {
            player.vy = -player.wallJumpForceY;
            player.vx = -player.wallDirection * player.wallJumpForceX;
          }
        }

        if (player.isTouchingWall && !player.onGround && player.vy > 0) {
          player.vy = Math.min(player.vy, player.wallSlideSpeed);
        }

        player.x += player.vx;
        player.y += player.vy;

        // Ground collision (using player.size / 2)
        if (player.y + player.size / 2 > canvas.height) {
          player.y = canvas.height - player.size / 2;
          player.vy = 0;
          player.onGround = true;
        } else {
          player.onGround = false;
        }

        // Ceiling collision (using player.size / 2)
        if (player.y - player.size / 2 < 0) {
          player.y = player.size / 2;
          if (player.vy < 0) player.vy *= -0.2;
        }

        keyUpJustPressed = false;
      }

      function manageTail() {
        tailSpawnCounter++;
        const speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
        if (speed > 0.5 && tailSpawnCounter >= TAIL_SPAWN_INTERVAL) {
          tailParticles.push({
            x: player.x,
            y: player.y,
            radius: (player.size / 2) * 0.8, // Particle radius based on player size
            originalRadius: (player.size / 2),
            color: player.color,
            life: TAIL_LIFETIME,
            maxLife: TAIL_LIFETIME,
          });
          tailSpawnCounter = 0;
        }
        if (tailParticles.length > MAX_TAIL_PARTICLES) tailParticles.shift();

        for (let i = tailParticles.length - 1; i >= 0; i--) {
          const p = tailParticles[i];
          p.life--;
          if (p.life <= 0) {
            tailParticles.splice(i, 1);
          } else {
            ctx.beginPath();
            const currentRadius = p.originalRadius * (p.life / p.maxLife);
            const currentAlpha = 0.8 * (p.life / p.maxLife);
            ctx.arc(p.x, p.y, Math.max(0, currentRadius), 0, Math.PI * 2); // Tail particles are still circles
            const rgb = hexToRgb(p.color);
            if (rgb)
              ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${currentAlpha})`;
            else ctx.fillStyle = `rgba(0, 255, 0, ${currentAlpha})`; // Fallback to green if hex fails
            ctx.fill();
            ctx.closePath();
          }
        }
      }

      function hexToRgb(hex) {
        if (!hex) return null;
        const localHex = hex.startsWith("#") ? hex.slice(1) : hex;
        if (localHex.length !== 6) return null;
        const r = parseInt(localHex.substring(0, 2), 16);
        const g = parseInt(localHex.substring(2, 4), 16);
        const b = parseInt(localHex.substring(4, 6), 16);
        if (isNaN(r) || isNaN(g) || isNaN(b)) return null;
        return { r, g, b };
      }

      function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        updatePlayer();
        manageTail();
        drawPlayer();
        requestAnimationFrame(gameLoop);
      }
      gameLoop();
    </script>
  </body>
</html>
