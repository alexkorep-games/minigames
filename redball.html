<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball with Tail</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #333; /* Dark background for contrast */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: sans-serif;
            color: white;
        }
        canvas {
            border: 1px solid #555;
            background-color: #282c34; /* A slightly different dark for the canvas */
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <p>Controls:</p>
        <ul>
            <li>Left/Right Arrows or A/D: Move</li>
            <li>Up Arrow or W or Space: Jump</li>
        </ul>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Canvas setup
        canvas.width = 800;
        canvas.height = 600;

        // Ball properties
        const ball = {
            x: canvas.width / 2,
            y: canvas.height - 50,
            radius: 20,
            color: 'red',
            eyeColor: 'white',
            pupilColor: 'black',
            vx: 0, // velocity x
            vy: 0, // velocity y
            mass: 1,
            jumpForce: 13,
            moveSpeed: 0.8, // acceleration
            maxSpeedX: 7,
            onGround: false
        };

        // Environment
        const gravity = 0.6;
        const friction = 0.9; // Air friction for horizontal movement
        const groundFriction = 0.85; // Friction when on ground

        // Tail particles
        let tailParticles = [];
        const MAX_TAIL_PARTICLES = 60;
        const TAIL_LIFETIME = 30; // frames
        const TAIL_SPAWN_INTERVAL = 1; // Spawn tail every N frames if moving
        let tailSpawnCounter = 0;

        // Input handling
        const keys = {
            left: false,
            right: false,
            up: false
        };

        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') keys.left = true;
            if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') keys.right = true;
            if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w' || e.key === ' ') keys.up = true;
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') keys.left = false;
            if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') keys.right = false;
            if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w' || e.key === ' ') keys.up = false;
        });

        function drawBall() {
            // Main ball
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = ball.color;
            ctx.fill();
            ctx.closePath();

            // Eyes
            const eyeRadius = ball.radius * 0.3;
            const eyeOffsetX = ball.radius * 0.4;
            const eyeOffsetY = ball.radius * 0.15;

            // Left eye
            ctx.beginPath();
            ctx.arc(ball.x - eyeOffsetX, ball.y - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.fillStyle = ball.eyeColor;
            ctx.fill();
            ctx.closePath();

            // Right eye
            ctx.beginPath();
            ctx.arc(ball.x + eyeOffsetX, ball.y - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.fillStyle = ball.eyeColor;
            ctx.fill();
            ctx.closePath();

            // Pupils
            const pupilRadius = eyeRadius * 0.5;
            let pupilLookOffset = 0;
            if (ball.vx > 0.5) pupilLookOffset = eyeRadius * 0.3;
            if (ball.vx < -0.5) pupilLookOffset = -eyeRadius * 0.3;
            
            const pupilOffsetY = 0; // Can adjust if you want them to look up/down

            // Left pupil
            ctx.beginPath();
            ctx.arc(ball.x - eyeOffsetX + pupilLookOffset, ball.y - eyeOffsetY + pupilOffsetY, pupilRadius, 0, Math.PI * 2);
            ctx.fillStyle = ball.pupilColor;
            ctx.fill();
            ctx.closePath();

            // Right pupil
            ctx.beginPath();
            ctx.arc(ball.x + eyeOffsetX + pupilLookOffset, ball.y - eyeOffsetY + pupilOffsetY, pupilRadius, 0, Math.PI * 2);
            ctx.fillStyle = ball.pupilColor;
            ctx.fill();
            ctx.closePath();
        }

        function updateBall() {
            // Horizontal movement
            if (keys.left) {
                ball.vx -= ball.moveSpeed;
            }
            if (keys.right) {
                ball.vx += ball.moveSpeed;
            }

            // Apply friction
            if (ball.onGround) {
                ball.vx *= groundFriction;
            } else {
                ball.vx *= friction; // Air friction
            }
            
            // Cap horizontal speed
            if (ball.vx > ball.maxSpeedX) ball.vx = ball.maxSpeedX;
            if (ball.vx < -ball.maxSpeedX) ball.vx = -ball.maxSpeedX;


            // Vertical movement (jump)
            if (keys.up && ball.onGround) {
                ball.vy = -ball.jumpForce;
                ball.onGround = false;
            }

            // Apply gravity
            ball.vy += gravity;

            // Update position
            ball.x += ball.vx;
            ball.y += ball.vy;

            // Collision with ground (bottom of canvas)
            if (ball.y + ball.radius > canvas.height) {
                ball.y = canvas.height - ball.radius;
                ball.vy = 0; // Stop vertical movement
                ball.onGround = true;
            } else {
                ball.onGround = false; // In the air
            }

            // Collision with walls (sides of canvas)
            if (ball.x - ball.radius < 0) {
                ball.x = ball.radius;
                ball.vx *= -0.5; // Bounce slightly
            }
            if (ball.x + ball.radius > canvas.width) {
                ball.x = canvas.width - ball.radius;
                ball.vx *= -0.5; // Bounce slightly
            }
            
            // Collision with ceiling (top of canvas)
            if (ball.y - ball.radius < 0) {
                ball.y = ball.radius;
                ball.vy *= -0.5; // Bounce slightly
            }
        }

        function manageTail() {
            tailSpawnCounter++;
            // Spawn new particle if moving and interval met
            const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (speed > 0.5 && tailSpawnCounter >= TAIL_SPAWN_INTERVAL) { // Only spawn if moving significantly
                tailParticles.push({
                    x: ball.x,
                    y: ball.y,
                    radius: ball.radius * 0.8, // Tail particles are slightly smaller
                    originalRadius: ball.radius * 0.8,
                    color: ball.color,
                    life: TAIL_LIFETIME,
                    maxLife: TAIL_LIFETIME
                });
                tailSpawnCounter = 0;
            }

            // Limit tail length
            if (tailParticles.length > MAX_TAIL_PARTICLES) {
                tailParticles.shift(); // Remove oldest particle
            }

            // Update and draw tail particles
            for (let i = tailParticles.length - 1; i >= 0; i--) {
                const p = tailParticles[i];
                p.life--;

                if (p.life <= 0) {
                    tailParticles.splice(i, 1); // Remove dead particle
                } else {
                    // Draw particle (fading and shrinking)
                    ctx.beginPath();
                    const currentRadius = p.originalRadius * (p.life / p.maxLife);
                    const currentAlpha = 0.8 * (p.life / p.maxLife); // Max alpha 0.8 for softer tail
                    ctx.arc(p.x, p.y, Math.max(0, currentRadius), 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${hexToRgb(p.color).r}, ${hexToRgb(p.color).g}, ${hexToRgb(p.color).b}, ${currentAlpha})`;
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }
        // Ensure 'red' is converted correctly
        if (ball.color.toLowerCase() === 'red') ball.color = '#FF0000';


        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update and draw
            updateBall();
            manageTail(); // Draw tail first so ball is on top
            drawBall();   // Draw ball on top of tail

            requestAnimationFrame(gameLoop);
        }

        // Start the game
        gameLoop();
    </script>
</body>
</html>