<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bouncing Ball with Wall Jump</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #333; /* Dark background for contrast */
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: sans-serif;
        color: white;
      }
      canvas {
        border: 1px solid #555;
        background-color: #282c34; /* A slightly different dark for the canvas */
      }
      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <p>Controls:</p>
      <ul>
        <li>Left/Right Arrows or A/D: Move</li>
        <li>Up Arrow or W or Space: Jump / Wall Jump</li>
      </ul>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Canvas setup
      canvas.width = 800;
      canvas.height = 600;

      // Ball properties
      const ball = {
        x: canvas.width / 2,
        y: canvas.height - 100, // Start a bit higher to ensure not on ground initially
        radius: 20,
        color: "#FF0000", // Explicit hex for red
        eyeColor: "white",
        pupilColor: "black",
        vx: 0, // velocity x
        vy: 0, // velocity y
        mass: 1,
        jumpForce: 13,
        moveSpeed: 0.8, // acceleration
        maxSpeedX: 7,
        onGround: false,
        // Wall interaction properties
        isTouchingWall: false,
        wallDirection: 0, // -1 for left, 1 for right, 0 for none
        wallSlideSpeed: 1.5, // Slower fall speed when against a wall
        wallJumpForceX: 8, // Horizontal force for wall jump
        wallJumpForceY: 12, // Vertical force for wall jump
      };

      // Environment
      const gravity = 0.6;
      const friction = 0.9; // Air friction for horizontal movement
      const groundFriction = 0.85; // Friction when on ground

      // Tail particles
      let tailParticles = [];
      const MAX_TAIL_PARTICLES = 60;
      const TAIL_LIFETIME = 30; // frames
      const TAIL_SPAWN_INTERVAL = 1; // Spawn tail every N frames if moving
      let tailSpawnCounter = 0;

      // Input handling
      const keys = {
        left: false,
        right: false,
        up: false, // Tracks if the jump key is currently HELD DOWN
      };
      let keyUpJustPressed = false; // Will be true for one frame when jump key is pressed

      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a")
          keys.left = true;
        if (e.key === "ArrowRight" || e.key.toLowerCase() === "d")
          keys.right = true;
        if (
          e.key === "ArrowUp" ||
          e.key.toLowerCase() === "w" ||
          e.key === " "
        ) {
          if (!keys.up) {
            // Only set keyUpJustPressed if it wasn't already down (fresh press)
            keyUpJustPressed = true;
          }
          keys.up = true; // Mark that the key is being held
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a")
          keys.left = false;
        if (e.key === "ArrowRight" || e.key.toLowerCase() === "d")
          keys.right = false;
        if (
          e.key === "ArrowUp" ||
          e.key.toLowerCase() === "w" ||
          e.key === " "
        ) {
          keys.up = false;
          // keyUpJustPressed is reset at the end of updateBall()
        }
      });

      function drawBall() {
        // Main ball
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = ball.color;
        ctx.fill();
        ctx.closePath();

        // Eyes
        const eyeRadius = ball.radius * 0.3;
        const eyeOffsetX = ball.radius * 0.4;
        const eyeOffsetY = ball.radius * 0.15;

        // Left eye
        ctx.fillStyle = ball.eyeColor; // Set fillStyle once for both eyes
        ctx.beginPath();
        ctx.arc(
          ball.x - eyeOffsetX,
          ball.y - eyeOffsetY,
          eyeRadius,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.closePath();

        // Right eye
        ctx.beginPath();
        ctx.arc(
          ball.x + eyeOffsetX,
          ball.y - eyeOffsetY,
          eyeRadius,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.closePath();

        // Pupils
        const pupilRadius = eyeRadius * 0.5;
        let pupilLookOffset = 0;
        // Make pupils look in direction of movement only if significant movement
        if (ball.vx > 0.5) pupilLookOffset = eyeRadius * 0.3;
        else if (ball.vx < -0.5) pupilLookOffset = -eyeRadius * 0.3;

        const pupilOffsetY = 0;

        ctx.fillStyle = ball.pupilColor; // Set fillStyle once for both pupils
        // Left pupil
        ctx.beginPath();
        ctx.arc(
          ball.x - eyeOffsetX + pupilLookOffset,
          ball.y - eyeOffsetY + pupilOffsetY,
          pupilRadius,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.closePath();

        // Right pupil
        ctx.beginPath();
        ctx.arc(
          ball.x + eyeOffsetX + pupilLookOffset,
          ball.y - eyeOffsetY + pupilOffsetY,
          pupilRadius,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.closePath();
      }

      function updateBall() {
        // Horizontal movement input
        if (keys.left) {
          ball.vx -= ball.moveSpeed;
        }
        if (keys.right) {
          ball.vx += ball.moveSpeed;
        }

        // Apply friction
        if (ball.onGround) {
          ball.vx *= groundFriction;
        } else {
          ball.vx *= friction; // Air friction
        }

        // Cap horizontal speed
        ball.vx = Math.max(-ball.maxSpeedX, Math.min(ball.maxSpeedX, ball.vx));

        // Apply gravity
        ball.vy += gravity;

        // --- Wall Interaction Logic ---
        ball.isTouchingWall = false; // Reset per frame, will be set true if collision occurs
        ball.wallDirection = 0; // Reset per frame

        // Left Wall Check
        if (ball.x - ball.radius <= 0) {
          ball.x = ball.radius;
          if (ball.vx < 0) ball.vx = 0; // Stop movement into wall
          ball.isTouchingWall = true;
          ball.wallDirection = -1;
        }
        // Right Wall Check (use 'else if' to avoid issues if perfectly in a corner, though unlikely)
        else if (ball.x + ball.radius >= canvas.width) {
          ball.x = canvas.width - ball.radius;
          if (ball.vx > 0) ball.vx = 0; // Stop movement into wall
          ball.isTouchingWall = true;
          ball.wallDirection = 1;
        }

        // Jump Logic (uses keyUpJustPressed for single action per press)
        if (keyUpJustPressed) {
          if (ball.onGround) {
            ball.vy = -ball.jumpForce;
            // ball.onGround will be set to false later based on position
          } else if (ball.isTouchingWall && !ball.onGround) {
            // Wall Jump condition
            ball.vy = -ball.wallJumpForceY;
            ball.vx = -ball.wallDirection * ball.wallJumpForceX; // Push away from wall
          }
        }

        // Wall Slide Logic
        // Apply after jump logic, as jump might push away from wall
        // Only slide if actually touching wall AND falling downwards
        if (ball.isTouchingWall && !ball.onGround && ball.vy > 0) {
          ball.vy = Math.min(ball.vy, ball.wallSlideSpeed);
        }

        // Update position based on velocity
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Collision with ground (bottom of canvas)
        if (ball.y + ball.radius > canvas.height) {
          ball.y = canvas.height - ball.radius;
          ball.vy = 0; // Stop vertical movement
          ball.onGround = true;
        } else {
          ball.onGround = false; // In the air
        }

        // Collision with ceiling (top of canvas)
        if (ball.y - ball.radius < 0) {
          ball.y = ball.radius;
          if (ball.vy < 0) ball.vy *= -0.2; // Dampen bounce from ceiling slightly
        }

        // Reset the single-press jump flag AFTER all jump logic for this frame is done
        keyUpJustPressed = false;
      }

      function manageTail() {
        tailSpawnCounter++;
        // Spawn new particle if moving and interval met
        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
        if (speed > 0.5 && tailSpawnCounter >= TAIL_SPAWN_INTERVAL) {
          // Only spawn if moving significantly
          tailParticles.push({
            x: ball.x,
            y: ball.y,
            radius: ball.radius * 0.8, // Tail particles are slightly smaller
            originalRadius: ball.radius * 0.8,
            color: ball.color, // Assumes ball.color is a hex string
            life: TAIL_LIFETIME,
            maxLife: TAIL_LIFETIME,
          });
          tailSpawnCounter = 0;
        }

        // Limit tail length
        if (tailParticles.length > MAX_TAIL_PARTICLES) {
          tailParticles.shift(); // Remove oldest particle
        }

        // Update and draw tail particles
        for (let i = tailParticles.length - 1; i >= 0; i--) {
          const p = tailParticles[i];
          p.life--;

          if (p.life <= 0) {
            tailParticles.splice(i, 1); // Remove dead particle
          } else {
            // Draw particle (fading and shrinking)
            ctx.beginPath();
            const currentRadius = p.originalRadius * (p.life / p.maxLife);
            const currentAlpha = 0.8 * (p.life / p.maxLife); // Max alpha 0.8 for softer tail
            ctx.arc(p.x, p.y, Math.max(0, currentRadius), 0, Math.PI * 2);

            const rgb = hexToRgb(p.color); // Convert hex to RGB for rgba
            if (rgb) {
              // Check if conversion was successful
              ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${currentAlpha})`;
            } else {
              ctx.fillStyle = `rgba(255, 0, 0, ${currentAlpha})`; // Default to red if conversion fails
            }
            ctx.fill();
            ctx.closePath();
          }
        }
      }

      function hexToRgb(hex) {
        if (!hex) return null;
        // Remove # if present
        const localHex = hex.startsWith("#") ? hex.slice(1) : hex;
        if (localHex.length !== 6) return null; // Basic validation

        const r = parseInt(localHex.substring(0, 2), 16);
        const g = parseInt(localHex.substring(2, 4), 16);
        const b = parseInt(localHex.substring(4, 6), 16);

        if (isNaN(r) || isNaN(g) || isNaN(b)) return null; // Check if parsing failed

        return { r, g, b };
      }

      function gameLoop() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Update and draw
        updateBall();
        manageTail(); // Draw tail first so ball is on top
        drawBall(); // Draw ball on top of tail

        requestAnimationFrame(gameLoop);
      }

      // Start the game
      gameLoop();
    </script>
  </body>
</html>
