<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Runner Prototype</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            display: block;
            background-color: #000;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
      // Generated by https://deepmind.google.com/frontiers/gemini-diffusion?tid=-6861022926066417663
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let canvasWidth = 0;
        let canvasHeight = 0;

        let shipX = 0;
        let shipY = 0;
        let shipZ = 0;
        let shipRotation = 0;
        let shipSpeed = 0;
        let shipRotationSpeed = 0;

        let stars = [];
        const numStars = 200;

        // Scaled ship vertices by 4
        const shipVertices = [
            [-40, -40, 0],
            [ 40, -40, 0],
            [  0,  60, 0],
            [  0,   0, 80]
        ];

        const shipEdges = [
            [0, 1], [1, 2], [2, 0],
            [0, 3], [1, 3], [2, 3]
        ];

        function resizeCanvas() {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            shipX = canvasWidth / 2;
            shipY = canvasHeight * 0.8;
            shipZ = 500;
        }

        function createStars() {
            stars = [];
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * canvasWidth,
                    y: Math.random() * canvasHeight,
                    z: Math.random() * 1000 + 100,
                    size: Math.random() * 1.5 + 0.5
                });
            }
        }

        function updateStars() {
            for (let i = 0; i < numStars; i++) {
                const star = stars[i];
                star.z -= shipSpeed * 0.5;
                if (star.z < 0) {
                    star.z += 1100;
                    star.x = Math.random() * canvasWidth;
                    star.y = Math.random() * canvasHeight;
                }
            }
        }

        function drawStars() {
            ctx.fillStyle = '#fff';
            for (let i = 0; i < numStars; i++) {
                const star = stars[i];
                const perspective = 500 / (star.z + 500);
                const size = star.size * perspective;
                ctx.beginPath();
                ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function projectPoint(point, objectZ, objectRotation) {
            let x = point[0];
            let y = point[1];
            let z = point[2];

            const cosR = Math.cos(objectRotation);
            const sinR = Math.sin(objectRotation);
            const rotatedX = x * cosR + z * sinR;
            const rotatedZ = -x * sinR + z * cosR;

            x = rotatedX;
            z = rotatedZ;

            const perspectiveFactor = 500;
            const scale = perspectiveFactor / (z + objectZ + perspectiveFactor);

            const projectedX = shipX + x * scale;
            const projectedY = shipY - y * scale; // Mirror Y-axis by negating y

            return { x: projectedX, y: projectedY, scale: scale };
        }

        function drawShip() {
            const projectedVertices = shipVertices.map(v => projectPoint(v, shipZ, shipRotation));

            ctx.strokeStyle = '#fff';
            const avgScale = projectedVertices.reduce((acc, p) => acc + (p.scale || 1), 0) / projectedVertices.length;
            ctx.lineWidth = Math.max(0.5, 2 * avgScale);

            ctx.beginPath();
            shipEdges.forEach(edge => {
                const p1 = projectedVertices[edge[0]];
                const p2 = projectedVertices[edge[1]];
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            });
            ctx.stroke();
        }

        let touchStartX = 0;
        let targetRotationSpeed = 0;
        let currentTouchX = 0;
        let isTouching = false;

        canvas.addEventListener('touchstart', (e) => {
            isTouching = true;
            touchStartX = e.touches[0].clientX;
            currentTouchX = touchStartX;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (!isTouching) return;
            e.preventDefault();
            const newTouchX = e.touches[0].clientX;
            const deltaX = newTouchX - currentTouchX;
            currentTouchX = newTouchX;

            targetRotationSpeed = (deltaX / (canvasWidth * 0.2)) * 0.05;
            const maxInputSpeed = 0.1;
            targetRotationSpeed = Math.max(-maxInputSpeed, Math.min(maxInputSpeed, targetRotationSpeed));
        });

        canvas.addEventListener('touchend', () => {
            isTouching = false;
            targetRotationSpeed = 0;
        });
        canvas.addEventListener('touchcancel', () => {
            isTouching = false;
            targetRotationSpeed = 0;
        });

        let isLeftKeyPressed = false;
        let isRightKeyPressed = false;
        let isUpKeyPressed = false;
        let isDownKeyPressed = false;

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                isLeftKeyPressed = true;
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                isRightKeyPressed = true;
            } else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') {
                isUpKeyPressed = true;
            } else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
                isDownKeyPressed = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                isLeftKeyPressed = false;
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                isRightKeyPressed = false;
            } else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') {
                isUpKeyPressed = false;
            } else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
                isDownKeyPressed = false;
            }
        });

        function updateShip() {
            let keyboardTargetSpeed = 0;
            if (isLeftKeyPressed) {
                keyboardTargetSpeed -= 0.02;
            }
            if (isRightKeyPressed) {
                keyboardTargetSpeed += 0.02;
            }

            let combinedTargetSpeed = targetRotationSpeed + keyboardTargetSpeed;

            if (isLeftKeyPressed || isRightKeyPressed || isTouching && targetRotationSpeed !== 0) {
                 shipRotationSpeed += combinedTargetSpeed;
            }

            shipRotationSpeed *= 0.92;

            const maxActualTiltSpeed = 0.05;
            shipRotationSpeed = Math.max(-maxActualTiltSpeed, Math.min(maxActualTiltSpeed, shipRotationSpeed));

            shipRotation += shipRotationSpeed;

            const maxTiltAngle = Math.PI / 4;
            shipRotation = Math.max(-maxTiltAngle, Math.min(maxTiltAngle, shipRotation));

            if (isTouching) {
                targetRotationSpeed = 0;
            }

            if (isUpKeyPressed) {
                shipY -= 5;
            }
            if (isDownKeyPressed) {
                shipY += 5;
            }

            shipY = Math.max(50, Math.min(canvasHeight - 50, shipY));

            // Horizontal movement with arrow keys
            if (isLeftKeyPressed) {
                shipX -= 5; // Adjust horizontal speed
            }
            if (isRightKeyPressed) {
                shipX += 5; // Adjust horizontal speed
            }

            // Keep ship within reasonable screen bounds horizontally
            shipX = Math.max(50, Math.min(canvasWidth - 50, shipX));
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        createStars();

        shipSpeed = 5;
        shipRotation = Math.PI; // Initial rotation to 180 degrees (PI radians)
        shipRotationSpeed = 0;

        gameLoop();

        function gameLoop() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            updateStars();
            drawStars();

            updateShip();
            drawShip();

            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
